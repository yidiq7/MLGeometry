"""Defines a Python class for hypersurfaces"""  

from multiprocessing import Pool
import mpmath

import numpy as np
import sympy as sp
import tensorflow as tf

__all__ = ['Hypersurface', 'RealHypersurface', 'diff', 'diff_conjugate']

class Hypersurface():
    r"""A hypersurface or patch defined both symbolically and numerically.

    The Hypersuface class contains the symbolic polynomial representation of a
    hypersurface in sympy. It is also numerically defined as a collection of
    points on the hypersurface. The points are sperated into patches, which are
    also collectons of points. Therefore, recursively, the patches can also be
    defined as instances of the Hypersurface class. 

                           Hypersurface
                           /     |     \
                      patch1   patch2  patch3   (Also Hypersurface class)
                      /  |  \  / | \   / | \
               subpatch ..  ..  .. ..   .. .. 

    Attribute:
    -------------
    coordinates: 
        The homogeneous coordinates as a list of sympy symbols, e.g. 
        z0, z1, z2, z3, z4 = sp.symbols('z0, z1, z2, z3, z4')    
        Z = [z0, z2, z3, z3, z4]
    function: 
        A function of the homogeneous coordiantes, e.g.
        f = z0**5 + z1**5 + z2**5 + z3**5 + z4**5 + 0.5*z0*z1*z2*z3*z4 
        The hypersurface is defined by f = 0
    n_dim: The number of homogeneous coordiantes.
    norm_coordinate:
        Applicable if the instance is a patch. An integer representing the
        index of the coordinate set to 1 on the affine patch. The first level 
        of patches are defined with this coordinate. The corresponding symbolic 
        coordinate is self.coordiante[self.norm_coordiante].
    affine_coordinates:
        The coordiantes on the affine patches (withouth the norm_coordinate). 
    max_grad_coordinate:
        The index of the affine coordinate with the largest |∂f/∂z_i|. The 
        second level of patches (subpatches) are defined using this coordinate,
        so that when one computes the holomorphic n-form
        Omega = 1/(∂f/∂z_i) * (dz_1 ^ ... dz_{i-1} ^ dz_{i+1} ^ ... dz_N),
        it is less likely to have a small number on the denominator.
        The corresponding symbolic coordinate is 
        self.affine_coordinate[self.max_grad_coordinate].
    patches: A list of instances of the subpatches of the hypersurface/patch
    points: The numerical points generated by Monte Carlo.
    n_points: The total number of points on the hypersurface or a patch. 
    grad: A list of symbolic expressions of ∂f/∂z_i       

    Usage:
    ----------
    Firstly, one needs to define the coordinates and function with sympy,
    and the number of pairs of points used in Monte Carlo:

    z0, z1, z2, z3, z4 = sp.symbols('z0, z1, z2, z3, z4')    
    Z = [z0, z2, z3, z3, z4]
    f = z0**5 + z1**5 + z2**5 + z3**5 + z4**5 + 0.5*z0*z1*z2*z3*z4 
    n_pairs = 1000

    Then define the hypersurface with f = 0:

    HS = MLGeometry.hypersurface.Hypersurface(Z, f, npairs)  

    """
    def __init__(self, 
                 coordinates, 
                 function,
                 n_pairs=0, 
                 points=None, 
                 norm_coordinate=None,
                 max_grad_coordinate=None):
        """Initialize the hypersurface
       
        Given the sympy coordinates Z, function f and npairs, there are two
        main steps on the highest level:  
        1. Generate points using Monte Carlo methods with __solve_points()
        2. Define the patches automatically with autopatch()
        On the patches, the points are calculated with autopatch() 
        beforehand and passed as an argument. 

        """
        self.coordinates = np.array(coordinates)
        self.function = function
        self.n_dim = len(self.coordinates)
        self.norm_coordinate = norm_coordinate
        if norm_coordinate is not None:
            self.affine_coordinates = np.delete(self.coordinates, norm_coordinate)
        else:
            self.affine_coordinates = self.coordinates
        self.max_grad_coordinate = max_grad_coordinate
        self.patches = []
        if points is None:
            self.points = self.solve_points(n_pairs)
            self.autopatch()
        else:
            self.points = points
        #self.n_patches = len(self.patches)
        self.n_points = len(self.points)
        self.grad = self.get_grad()

    def solve_points(self, n_pairs):
        """Generates random points on the hypersurface with Monte Carlo

        #TODO explain the MC method or refer to the paper

        Args:
        --------
        n_pairs: The number of random pair used in Monte carlo.
  
        Returns:
        --------
        A list of random complex points on the hypersurface, where the points
        themselves are a list of complex coordiantes with dtype Complex128.

        """ 
        zpairs = self.generate_random_projective(n_pairs, 2)
        coeff_a = [sp.symbols('a'+str(i)) for i in range(self.n_dim)]
        coeff_b = [sp.symbols('b'+str(i)) for i in range(self.n_dim)]
        c = sp.symbols('c')
        coeff_zip = zip(coeff_a, coeff_b)
        line = [c*a+b for (a, b) in coeff_zip]
        function_eval = self.function.subs([(self.coordinates[i], line[i])
                                            for i in range(self.n_dim)])
        poly = sp.Poly(function_eval, c)
        coeff_poly = poly.coeffs()
        get_coeff = sp.lambdify([coeff_a, coeff_b], coeff_poly)

        points = self.solve_points_multiprocessing(zpairs, get_coeff)

        return points

    def solve_points_multiprocessing(self, zpairs, get_coeff):
        points = []
        # Multiprocessing. Then append the points to the same list in the main process
        with Pool() as pool:
            for points_d in pool.starmap(Hypersurface.solve_poly,
                                         zip(zpairs, [get_coeff(zpair[0], zpair[1])
                                                      for zpair in zpairs])):
                points.extend(points_d)
        return points

    def generate_random_projective(self, n_set, n_pt_in_a_set):
        """Generate sets of points in CP^N

        Args:
        --------
        n_set: The total number of sets/complex lines/planes sampled. Equivalent
               to n_pairs when there are 2 points in each set.

        n_pt_in_a_set: The number of points in a set. For pairs it equals to 2 and
                       for trios it equal to 3, etc.

        Returns:
        --------
        A list of random points in (CP^N)^n_point

        """
        z_random = []
        for i in range(n_set):
            zv = []
            for j in range(n_pt_in_a_set):
                zv.append([complex(c[0],c[1]) for c in np.random.normal(0.0, 1.0, (self.n_dim, 2))])
            z_random.append(zv)
        return z_random

    @staticmethod
    def solve_poly(zpair, coeff):
        # For each zpair there are d solutions, where d is the n_dim
        points_d = []
        c_solved = mpmath.polyroots(coeff) 
        for pram_c in c_solved:
            points_d.append([complex(pram_c * a + b)
                             for (a, b) in zip(zpair[0], zpair[1])])
        return points_d
    
    def autopatch(self):
        # projective patches
        points_on_patch = [[] for i in range(self.n_dim)]
        for point in self.points:
            norms = np.absolute(point)
            for i in range(self.n_dim):
                if norms[i] == max(norms):
                    point_normalized = self.normalize_point(point, i)
                    points_on_patch[i].append(point_normalized)
                    continue
        for i in range(self.n_dim):
            if points_on_patch[i]:
                self.set_patch(points_on_patch[i], i)
        # Subpatches on each patch
        for patch in self.patches:
            points_on_patch = [[] for i in range(self.n_dim-1)]
            grad_eval = sp.lambdify(self.coordinates, patch.grad, 'numpy')
            for point in patch.points:
                grad = grad_eval(*point)
                grad_norm = np.absolute(grad)
                points_on_patch[np.argmax(grad_norm)].append(point)
            for i in range(self.n_dim-1):
                if points_on_patch[i]:
                    patch.set_patch(points_on_patch[i], patch.norm_coordinate,
                                    max_grad_coord=i)

    def set_patch(self, points_on_patch, norm_coord=None, max_grad_coord=None):
        new_patch = Hypersurface(self.coordinates, 
                                 self.function, 
                                 points=points_on_patch, 
                                 norm_coordinate=norm_coord,
                                 max_grad_coordinate=max_grad_coord)
        self.patches.append(new_patch)

    def list_patches(self):
        print("Number of Patches:", len(self.patches))
        i = 1
        for patch in self.patches:
            print("Points on patch", i, ":", len(patch.points))
            i = i + 1

    def normalize_point(self, point, norm_coordinate):
        point_normalized = []
        for coordinate in point:
            norm_coefficient = point[norm_coordinate]
            coordinate_normalized = coordinate / norm_coefficient
            point_normalized.append(coordinate_normalized)
        return point_normalized

    def get_FS(self):
        FS_metric = self.kahler_metric(np.identity(self.n_dim), k=1)
        return FS_metric

    def get_grad(self):
        grad = []
        for coord in self.affine_coordinates:
            grad_i = self.function.diff(coord)
            grad.append(grad_i)
        return grad

    def get_hol_n_form(self, coord):
        """

        Return:
        -------
        A or a list of symbolic expressions of the holomorphic n-form 1/(∂f/∂z_i)

        """
        hol_n_form = []
        if coord is not None:
            hol_n_form = 1 / self.grad[coord]
        else:
            for i in range(len(self.affine_coordinates)):
                hol_n_form.append(self.get_hol_n_form(i))
        return hol_n_form

    def get_omega_omegabar(self, lambdify=False):
        omega_omegabar = []
        if self.patches == [] and self.max_grad_coordinate is not None:
            hol_n_form = self.get_hol_n_form(self.max_grad_coordinate)
            omega_omegabar = hol_n_form * sp.conjugate(hol_n_form)
        else:
            for patch in self.patches:
                try:
                    omega_omegabar.append(patch.omega_omegabar)
                except AttributeError:
                    omega_omegabar.append(patch.get_omega_omegabar(lambdify=lambdify))

        if lambdify is True:
            OObar_func = sp.lambdify([self.coordinates], omega_omegabar,'numpy')
            omega_omegabar = lambda point: OObar_func(point).real
        return omega_omegabar

    def get_sections(self, k, lambdify=False):
        sections = []
        t = sp.symbols('t')
        GenSec = sp.prod(1/(1-(t*zz)) for zz in self.coordinates)
        poly = sp.series(GenSec, t, n=k+1).coeff(t**k)
        while poly!=0:
            sections.append(sp.LT(poly))
            poly = poly - sp.LT(poly)
        n_sections = len(sections)
        sections = np.array(sections)
        if lambdify is True:
            sections = sp.lambdify([self.coordinates], sections, 'numpy')
        return sections, n_sections

    def kahler_potential(self, h_matrix=None, k=1):
        sections, n_sec = self.get_sections(k)
        if h_matrix is None:
            h_matrix = np.identity(n_sec)
        # Check if h_matrix is a string
        elif isinstance(h_matrix, str):
            if h_matrix == "identity":
                h_matrix = np.identity(n_sec)
            elif h_matrix == "symbolic":
                h_matrix = sp.MatrixSymbol('H', n_sec, n_sec)

            elif h_matrix == "FS":
                h_matrix = np.diag(sp.Poly(sp.expand(sum(self.coordinates)**k)).coeffs())
        z_H_zbar = np.matmul(sections, np.matmul(h_matrix, sp.conjugate(sections)))
        if self.norm_coordinate is not None:
            z_H_zbar = z_H_zbar.subs(self.coordinates[self.norm_coordinate], 1)
        kahler_potential = sp.log(z_H_zbar)
        return kahler_potential

    def kahler_metric(self, h_matrix=None, k=1, point=None):
        if point is None:
            pot = self.kahler_potential(h_matrix, k)
            metric = []
            #i holomorphc, j anti-hol
            for coord_i in self.affine_coordinates:
                a_holo_der = []
                for coord_j in self.affine_coordinates:
                    a_holo_der.append(diff_conjugate(pot, coord_j))
                metric.append([diff(ah, coord_i) for ah in a_holo_der])
            metric = sp.Matrix(metric)

        return metric

    def get_restriction(self, ignored_coord=None, lambdify=False):
        if ignored_coord is None:
            ignored_coord = self.max_grad_coordinate
        ignored_coordinate = self.affine_coordinates[ignored_coord]
        local_coordinates = sp.Matrix(self.affine_coordinates).subs(ignored_coordinate, self.function)
        affine_coordinates = sp.Matrix(self.affine_coordinates)
        restriction = local_coordinates.jacobian(affine_coordinates).inv()
        restriction.col_del(ignored_coord)
        if lambdify is True:
            restriction = sp.lambdify([self.coordinates], restriction, 'numpy')
        return restriction

    def get_FS_volume_form(self, h_matrix=None, k=1, lambdify=False):
        kahler_metric = self.kahler_metric(h_matrix, k)
        restriction = self.get_restriction()
        FS_volume_form = restriction.T * kahler_metric * restriction.conjugate()
        FS_volume_form = FS_volume_form.det()
        if lambdify is True:
            FS_func = sp.lambdify([self.coordinates], FS_volume_form, 'numpy')
            FS_volume_form = lambda point: FS_func(point).real
        return FS_volume_form

    # Numerical Methods:

    def set_k(self, k):
        self.k = k
        sections, ns = self.get_sections(k, lambdify=False)
        sections_func, ns = self.get_sections(k, lambdify=True)
        self.n_sections = ns
        for patch in self.patches:
            # patch.k = k
            for subpatch in patch.patches:
                # subpatch.k = k
                subpatch.n_sections = ns
                subpatch.sections = sections_func
                jacobian = sp.Matrix(sections).jacobian(subpatch.affine_coordinates)
                subpatch.sections_jacobian = sp.lambdify([subpatch.coordinates],
                                                         jacobian,'numpy')
                subpatch.restriction = subpatch.get_restriction(lambdify=True)
                subpatch.omega_omegabar = subpatch.get_omega_omegabar(lambdify=True)
                subpatch.h_FS = np.diag(sp.Poly(sp.expand(sum(self.coordinates)**k)).coeffs())
                
                # Tensors
                subpatch.s_tf, subpatch.J_tf = subpatch.num_s_J_tf() 
                subpatch.s_tf_1, subpatch.J_tf_1 = subpatch.num_s_J_tf(k=1) 
                subpatch.Omega_Omegabar_tf = subpatch.num_Omega_Omegabar_tf()
                subpatch.r_tf = subpatch.num_restriction_tf()

    #@tf.function
    def num_s_J_tf(self, k=-1):

        s_vec = []
        J_vec = []

        for point in self.points:
            if k == 1:
                # k = 1 will be used in the mass formula during the integration
                s = [point]
                # Delete the correspoding row
                J = np.delete(np.identity(self.n_dim), self.norm_coordinate, 0)
            else:
                s = [self.sections(point)]
                J = self.sections_jacobian(point).T

            s_vec.append(s)
            J_vec.append(J)

        s_tf = tf.constant(np.array(s_vec, dtype=np.complex64))
        J_tf = tf.constant(np.array(J_vec, dtype=np.complex64))
        return s_tf, J_tf

    #@tf.function
    def num_Omega_Omegabar_tf(self):
        Omega_Omegabar = []
        for point in self.points:
            Omega_Omegabar.append(self.omega_omegabar(point))
        Omega_Omegabar = tf.constant(np.array(Omega_Omegabar, dtype=np.float32))
        return Omega_Omegabar

    #@tf.function
    def num_restriction_tf(self):
        # Maybe I shouldn't do transpose here. A little bit confusing but
        # I guarantee you that the calculations are correct
        r = []
        for point in self.points:
            r.append(self.restriction(point).T)
        r_tf = tf.constant(np.array(r, dtype=np.complex64))  
        return r_tf

    #@tf.function
    def num_kahler_metric_tf(self, h_matrix, k=-1):
        if isinstance(h_matrix, str):
            if h_matrix == 'identity':
                if k == 1:
                    h_matrix = np.identity(self.n_dim, dtype=np.complex64)
                else:
                    h_matrix = np.identity(self.n_sections, dtype=np.complex64)
            elif h_matrix == 'FS':
                h_matrix = self.h_FS.astype(np.complex64)
                #h_matrix = np.array(self.h_FS, dtype=np.complex64)

        #h_tf = tf.constant(h_matrix)
        #if isinstance(h_matrix, np.ndarray):
        h_tf = tf.convert_to_tensor(h_matrix, dtype=tf.complex64)

        if k == 1:
            s_tf = self.s_tf_1
            J_tf = self.J_tf_1
        else:
            s_tf = self.s_tf
            J_tf = self.J_tf    

        #h_tf = tf.cast(h_tf, tf.complex64)

        H_Jdag = tf.matmul(h_tf, J_tf, adjoint_b=True)
        A = tf.matmul(J_tf, H_Jdag)
        b = tf.matmul(s_tf, H_Jdag)
        B = tf.matmul(b, b, adjoint_a=True)
        alpha = tf.matmul(s_tf, tf.matmul(h_tf, s_tf, adjoint_b=True))
        G = A / alpha - B / alpha**2
        #if tf.reduce_min(tf.abs(alpha)) < 0.001:
        #    print('alpha: ', tf.reduce_min(alpha))
        return G

    #@tf.function
    def num_FS_volume_form_tf(self, h_matrix, k=-1):
        kahler_metric = self.num_kahler_metric_tf(h_matrix, k)
        r_tf = self.r_tf
        FS_volume_form = tf.matmul(r_tf, tf.matmul(kahler_metric, r_tf, adjoint_b=True))
        FS_volume_form = tf.linalg.det(FS_volume_form)
        FS_volume_form = tf.math.real(FS_volume_form)
        return FS_volume_form

    def num_kahler_metric(self, h_matrix, point, k=-1):
        if k == 1:
            # k = 1 will be used in the mass formula during the integration
            s = point
            # Delete the correspoding row
            J = np.delete(np.identity(len(s)), self.norm_coordinate, 0)
        else:
            s = self.sections(point)
            J = self.sections_jacobian(point).T
        if isinstance(h_matrix, str):
            if h_matrix == 'identity':
                h_matrix = np.identity(len(s))
            elif h_matrix == 'FS':
                h_matrix = np.array(self.h_FS, dtype=int)

        H_Jdag = np.matmul(h_matrix, np.conj(J).T)
        A = np.matmul(J, H_Jdag)
        # Get the right half of B then reshape to transpose,
        # since b.T is still b if b is a 1d vector
        b = np.matmul(s, H_Jdag).reshape(-1, 1)
        B = np.matmul(np.conj(b), b.T)
        alpha = np.matmul(s, np.matmul(h_matrix, np.conj(s)))
        G = A / alpha - B / alpha**2
        return G

    def num_FS_volume_form(self, h_matrix, point, k=-1):
        kahler_metric = self.num_kahler_metric(h_matrix, point, k)
        r = self.restriction(point)
        FS_volume_form = np.matmul(r.T, np.matmul(kahler_metric, np.conj(r)))
        FS_volume_form = np.matrix(FS_volume_form, dtype=complex)
        FS_volume_form = np.linalg.det(FS_volume_form).real
        return FS_volume_form

def diff_conjugate(expr, coordinate):
    coord_bar = sp.symbols('coord_bar')
    expr_diff = expr.subs(sp.conjugate(coordinate), coord_bar).diff(coord_bar)
    expr_diff = expr_diff.subs(coord_bar, sp.conjugate(coordinate))
    return expr_diff

def diff(expr, coordinate):
    coord_bar = sp.symbols('coord_bar')
    expr_diff = expr.subs(sp.conjugate(coordinate), coord_bar).diff(coordinate)
    expr_diff = expr_diff.subs(coord_bar, sp.conjugate(coordinate))
    return expr_diff


class RealHypersurface(Hypersurface):

    def generate_random_projective(self, n_set, n_pt_in_a_set):
        z_random= []
        for i in range(n_set):
            zv = []
            for j in range(n_pt_in_a_set):
                zv.append(np.random.normal(0.0, 1.0, self.n_dim).astype(complex))
            z_random.append(zv)
        return z_random

    def solve_points_multiprocessing(self, zpairs, get_coeff):
        points = []
        # Multiprocessing. Then append the points to the same list in the main process
        with Pool() as pool:
            for points_d in pool.starmap(RealHypersurface.solve_poly_real,
                                         zip(zpairs, [get_coeff(zpair[0], zpair[1])
                                                      for zpair in zpairs])):
                points.extend(points_d)
        return points


    @staticmethod
    def solve_poly_real(zpair, coeff):
        # For each zpair there are d solutions, where d is the n_dim
        # There will be one real solution and we will keep that only
        points_d = []
        try:
            c_solved = mpmath.polyroots(coeff) 
            for pram_c in c_solved:
                if np.abs(np.imag(pram_c)) < 1e-8:
                    points_d.append([complex(pram_c * a + b)
                                     for (a, b) in zip(zpair[0], zpair[1])])
        except:
            pass
        return points_d
 
